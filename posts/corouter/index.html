<!doctype html><html><head><meta charset=utf-8><title>Corouter</title><meta name=viewport content="width=device-width"><link rel=stylesheet type=text/css href=/css/hybrid.css><link rel=stylesheet type=text/css href=/css/style.css><link rel=stylesheet type=text/css href=/css/colors-dark.css></head><canvas id=background style="position:fixed;top:0;left:0;margin:0 auto;display:block;z-index:-99999"></canvas>
<script src=/js/perlin.js></script><script>var canvas=document.getElementById("background"),ctx=canvas.getContext("2d");canvas.width=screen.width;canvas.height=screen.height;var background=new Image();background.src="/img/colored_transparent.png";var drawImage=function(x,y,posX,posY){var size=background.width/32;ctx.drawImage(background,size*x,size*y,size,size,posX,posY,size,size);}
function getRandomInt(max){return Math.floor(Math.random()*Math.floor(max));}
var grass=[{x:5,y:0},{x:6,y:0},{x:7,y:0},{x:1,y:0},{x:2,y:0},{x:5,y:2},{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0},{x:0,y:0}];function randomGrass(){return grass[Math.floor(Math.random()*grass.length)]}
background.onload=function(){noise.seed(Math.random());var noiseScale=30;for(let x=0;x<canvas.width/16;x++){for(let y=0;y<canvas.height/16;y++){var localnoise=noise.simplex2(x/noiseScale,y/noiseScale);var weeds=localnoise>-0.85&&localnoise<-0.7;var rocks=localnoise>-0.8&&localnoise<-0.79;if(localnoise>0.3)
{drawImage(1*Math.floor(localnoise/0.3),1,x*16,y*16);}
else if(localnoise>-0.8)
{if(!weeds&&!rocks&&Math.random()<localnoise+0.8)
drawImage(randomGrass().x,randomGrass().y,x*16,y*16);}
else
{drawImage(8,5,x*16,y*16);}
if(weeds&&!rocks)
drawImage(0,2,x*16,y*16);if(rocks)
drawImage(5,2,x*16,y*16);}}}</script><body><header id=header><h1><a href>PixelYard</a></h1><p>Video game programming and related things.</p></header><div id=page><div id=sidebar><nav><ul><span>-----Useful (Maybe)</span><li><a href=/scraps/corouter/>Corouter</a></li><span>-----Categories</span><li><a href=/categories/coroutine/>Coroutine (1)</a></li><li><a href=/categories/csharp/>CSharp (1)</a></li><li><a href=/categories/unity3d/>Unity3D (1)</a></li></ul></nav></div><div id=content><article class=post><h1><a href=/posts/corouter/>Corouter</a></h1><div class=post-content><p>If you are looking for a full implementation with some nice add-ons like a fluent API (similar to reactive programming), take a look at my repository : <a href=https://github.com/paulfigiel/Corouter>Corouter</a>.</p><p>A few people really understand Unity coroutines, and for good reasons.
To clear things out first : unity coroutines are not running on another thread, it&rsquo;s just a simple way to delay calls to functions.</p><p>To do that, they use the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?view=netframework-4.8">C# IEnumerator</a> combined with the &ldquo;yield return&rdquo; language keyword.</p><hr><p>But Unity coroutines are not flexible though :</p><ul><li>you can&rsquo;t really modify the implementation to your needs</li><li>you can&rsquo;t reset a coroutine</li><li>no control over ticking rate</li><li>can&rsquo;t pause a coroutine</li><li>&hellip;</li></ul><p>So here is an implementation I made :</p><p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=color:#719e07>using</span> System;
<span style=color:#719e07>using</span> System.Collections;
<span style=color:#719e07>using</span> System.Collections.Generic;
<span style=color:#719e07>using</span> System.Threading;
<span style=color:#719e07>using</span> UnityEngine;

<span style=color:#719e07>public</span> <span style=color:#719e07>class</span> <span style=color:#268bd2>Routine</span>
    {
        List&lt;Func&lt;IEnumerator&gt;&gt; baseEnumerators = <span style=color:#719e07>new</span> List&lt;Func&lt;IEnumerator&gt;&gt;();
        <span style=color:#dc322f>int</span> enumeratorFuncIndex = <span style=color:#2aa198>0</span>;
        IEnumerator currentEnumerator;
        Stack&lt;IEnumerator&gt; enumeratorStack = <span style=color:#719e07>new</span> Stack&lt;IEnumerator&gt;();
        <span style=color:#719e07>private</span> <span style=color:#dc322f>bool</span> _running = <span style=color:#719e07>false</span>;
        <span style=color:#719e07>private</span> <span style=color:#dc322f>float</span> unpauseTime = <span style=color:#2aa198>0</span>;
        <span style=color:#719e07>public</span> <span style=color:#dc322f>bool</span> Running
        {
            <span style=color:#719e07>get</span>
            {
                <span style=color:#719e07>return</span> _running;
            }
        }

        <span style=color:#719e07>public</span> <span style=color:#dc322f>object</span> Current =&gt; currentEnumerator.Current;

        <span style=color:#719e07>public</span> Routine(<span style=color:#719e07>params</span> Func&lt;IEnumerator&gt;[] enumerators)
        {
            <span style=color:#719e07>if</span> (enumerators.Length &gt; <span style=color:#2aa198>0</span>)
            {
                baseEnumerators = <span style=color:#719e07>new</span> List&lt;Func&lt;IEnumerator&gt;&gt;(enumerators);
                currentEnumerator = baseEnumerators[0]();
            }
        }

        <span style=color:#719e07>public</span> <span style=color:#719e07>void</span> Start()
        {
            _running = <span style=color:#719e07>true</span>;
            CorouterManager.Instance.RegisterRoutine(<span style=color:#719e07>this</span>);
        }

        <span style=color:#719e07>public</span> <span style=color:#719e07>void</span> Stop()
        {
            _running = <span style=color:#719e07>false</span>;
        }

        <span style=color:#719e07>public</span> <span style=color:#719e07>void</span> Reset()
        {
            enumeratorFuncIndex = <span style=color:#2aa198>0</span>;
            currentEnumerator = baseEnumerators[0]();
        }

        <span style=color:#719e07>public</span> <span style=color:#719e07>void</span> Reboot()
        {
            Reset();
            Start();
        }

        <span style=color:#719e07>public</span> <span style=color:#dc322f>bool</span> Tick()
        {
            <span style=color:#719e07>if</span> (Time.time &lt; unpauseTime)
                <span style=color:#719e07>return</span> <span style=color:#719e07>true</span>;
            <span style=color:#dc322f>bool</span> currentHasNext = currentEnumerator != <span style=color:#719e07>null</span> &amp;&amp; currentEnumerator.MoveNext();
            <span style=color:#719e07>if</span> (currentHasNext)
            {
                <span style=color:#719e07>switch</span> (currentEnumerator.Current)
                {
                    <span style=color:#719e07>case</span> IEnumerator e:
                        enumeratorStack.Push(currentEnumerator);
                        currentEnumerator = e;
                        <span style=color:#719e07>break</span>;
                    <span style=color:#719e07>case</span> <span style=color:#dc322f>float</span> f:
                        unpauseTime = Time.time + f;
                        <span style=color:#719e07>break</span>;
                    <span style=color:#719e07>case</span> <span style=color:#719e07>null</span>:
                        <span style=color:#719e07>break</span>;
                    <span style=color:#719e07>default</span>:
                        <span style=color:#719e07>break</span>;
                }
                <span style=color:#719e07>return</span> <span style=color:#719e07>true</span>;
            }
            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (enumeratorStack.Count &gt; <span style=color:#2aa198>0</span>)
            {
                currentEnumerator = enumeratorStack.Pop();
                <span style=color:#719e07>return</span> <span style=color:#719e07>true</span>;
            }
            <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> (enumeratorFuncIndex + <span style=color:#2aa198>1</span> &lt; baseEnumerators.Count)
            {
                enumeratorFuncIndex++;
                currentEnumerator = baseEnumerators[enumeratorFuncIndex]();
                <span style=color:#719e07>return</span> <span style=color:#719e07>true</span>;
            }
            <span style=color:#719e07>else</span>
            {
                _running = <span style=color:#719e07>false</span>;
                <span style=color:#719e07>return</span> <span style=color:#719e07>false</span>;
            }
        }
    }
</code></pre></div>With a hypothetical CorouterManager that handles routine ticking.</p><p>We use a regular stack to remember nested Routine calls like a normal Unity Coroutine would behave.</p><p>And each time we iterate, we just check the type of the next yielded object to see how we are dealing with it.
In C# 6 this is easy with <a href=https://csharp.christiannagel.com/2017/02/15/patternmatching/>pattern matching</a>.</p><p>The trick, is also to remember the actual function lambdas in an array so you can reset the coroutine with the Reset(). function.</p><p>This example of routine can&rsquo;t run by itself, you need to manually call the Tick() function. You can also take a look at a full implementation I made <a href=https://github.com/paulfigiel/Corouter>HERE</a>.</p><p>Building on top of this becomes really simple, and you can extends the implementation to your needs.</p><p>For example, a way to simply start a Thread using coroutine would be :</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs>        <span style=color:#719e07>private</span> IEnumerator ThreadedEnumerator(System.Action action, <span style=color:#dc322f>object</span> lockobject = <span style=color:#719e07>null</span>)
        {
            <span style=color:#719e07>if</span> (lockobject == <span style=color:#719e07>null</span>)
                lockobject = <span style=color:#719e07>this</span>;
            Thread t = <span style=color:#719e07>new</span> Thread(
                () =&gt;
                {
                    <span style=color:#719e07>lock</span> (lockobject)
                    {
                        action();
                    }
                }
                );
            t.Start();
            <span style=color:#719e07>while</span> (t.IsAlive)
            {
                <span style=color:#719e07>yield</span> <span style=color:#719e07>return</span> <span style=color:#719e07>null</span>;
            }
        }
</code></pre></div></div><p class=meta>Posted on <span class=postdate>15. August 2019</span></p></article></div><footer id=footer><p class=copyright>Powered by
<a href=https://gohugo.io/>Hugo</a> based on the
<a href=https://github.com/bake/solar-theme-hugo>Solar</a>-theme.</p></footer></div></body></html>